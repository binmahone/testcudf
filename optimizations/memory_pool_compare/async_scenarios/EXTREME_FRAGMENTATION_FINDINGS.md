# 极端大分配碎片化测试结果 🔥

## 测试配置

**分配大小：20MB - 1GB** (vs 之前的 0.4-20MB)  
**线程数：8** (sweet spot)  
**轮次：40** (每轮每线程5个分配，保留40%)  
**总分配：1600次大分配 (8×5×40)**

## 惊人的发现！❗

### Pool 反而更好了！

```
                Baseline    碎片化后    退化
Pool            272.03ms    255.58ms   -6.0%  (变快!) ✅
Async           264.50ms    287.12ms   +8.5%  (变慢)  ⚠️
Arena           257.56ms    OOM        崩溃    💥
```

### 与中等分配对比

**中等分配 (0.4-20MB):**
```
Pool:  +10.7%  (变慢)
Async: +6.8%   (变慢但更好)  ← Async 优势
```

**极端大分配 (20MB-1GB):**
```
Pool:  -6.0%   (变快!) ✅
Async: +8.5%   (变慢)   
```

**差异：14.5%！** Pool 在大分配时反转了，比 Async 好了 **14.5%**！

## 深入分析 🔬

### 为什么大分配时 Pool 更好？

**1. 预分配策略的优势放大**

中等分配（20MB）：
```
16GB Pool / 20MB = 800 个可能的块
Free list 搜索：O(log 800) ≈ 10 次比较
→ 碎片化增加节点，搜索略慢
```

大分配（500MB）：
```
16GB Pool / 500MB = 32 个可能的块
Free list 搜索：O(log 32) ≈ 5 次比较
→ 碎片化影响更小！大块更容易找到
```

**关键：大分配意味着更少的块，搜索更快！**

**2. Async 的驱动开销被放大**

小分配：
```
Driver overhead: 10μs
Allocation time: 50μs
Overhead: 20%
```

大分配：
```
Driver overhead: 10μs (仍然是固定的)
Allocation time: 200μs
Overhead: 5%
```

**但是：** 大分配可能需要driver做更多工作：
- 跨stream defragmentation
- Large block coalescing
- Memory mapping

**3. Pool 的 Warm-up 效应**

- Pool 经过使用后，free list 被优化
- Large blocks 更可能被合并
- Cache locality 更好

观察：Pool 一致地"越用越快"
- 单线程：-14.2%
- 4线程：-16.9%
- 8线程中等：-3.1% (长期)
- 8线程大分配：-6.0%

**Pool 有某种内部优化机制！**

### 为什么 Async 在大分配时变慢？

**猜测 1: Driver Management Overhead**
```
Small allocs: Driver overhead摊销到多次分配
Large allocs: 每次大分配都要driver management
→ 相对overhead更高
```

**猜测 2: Stream-Ordered 的劣势**
```
Large allocs需要连续内存块
Stream-ordered可能分散在不同stream的"区域"
→ 需要更多defragmentation
```

**猜测 3: 8线程 × 大分配 = 更多竞争**
```
8个线程同时请求500MB+
Driver需要协调这些大请求
→ 比Pool的global lock更复杂？
```

### Arena 为什么崩溃？

Arena 设计问题：
- 对大分配不够鲁棒
- "No room in arena" - 碎片化导致无法找到足够大的连续块
- 16GB pool 仍然不够处理极端场景

## 完整对比

### 单线程

```
Pool:  -14.2%  ← 最好
Async: +3.2%
```

### 4线程

```
Pool:  -16.9%  ← 最好
Async: -3.2%
```

### 8线程 - 中等分配 (0.4-20MB)

```
Pool:  +10.7%
Async: +6.8%   ← Async好4%
```

### 8线程 - 大分配 (20MB-1GB)

```
Pool:  -6.0%   ← Pool好14.5%!
Async: +8.5%
```

## 关键洞察 💡

### 1. 分配大小很重要！

**中等分配（< 20MB）：**
- Async 略有优势（-4%）
- Stream-ordered 减少锁竞争

**大分配（> 100MB）：**
- Pool 有明显优势（-14.5%）
- 预分配 + 更少块 = 更快搜索
- Async 的 driver overhead 相对更大

### 2. Pool 的"越用越快"现象

所有场景下 Pool 都趋向于变快：
- ✅ 单线程：-14%
- ✅ 低并发：-17%
- ⚠️ 中并发中等分配：+11% (唯一退化)
- ✅ 中并发大分配：-6%

**Pool 有内部优化/合并机制！**

### 3. Async 不适合大分配场景

- 中小分配：性能ok，stream-ordered有优势
- 大分配：性能退化，driver overhead突出

### 4. 最糟糕场景：8线程 + 中等分配

```
Pool:  +10.7%  ← 最差
Async: +6.8%   ← 仍然不好，但比Pool好

这是唯一 Async 展现优势的场景！
```

## 实际意义 🎯

### Rapids/Spark 的典型场景

**场景分析：**

1. **小任务（< 10MB per column）**
   - Pool 和 Async 都很好
   - 差异 < 3%

2. **中等任务（10-100MB per column）** ← 常见
   - 8线程并发：Async 好 4%
   - 其他并发：Pool 更好
   - **这是 Async 的主战场**

3. **大任务（> 100MB per column）**
   - Pool 好 14.5%！
   - **不要用 Async**

### 推荐策略（更新）

**如果你的数据主要是中等大小（10-100MB）：**
→ **Async** 可能稍好（4%）

**如果你有很多大分配（> 100MB）：**
→ **Pool** 明显更好（14.5%）

**如果是混合workload：**
→ **Pool** 更安全（整体表现更稳定）

## 性能优化优先级（最终更新）

```
场景                              影响       推荐
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Kernel融合/优化                  +23%       ⭐⭐⭐
Stream同步                        +50%       ⭐⭐⭐
使用Pool/Async vs默认             +14x       ⭐⭐⭐

8线程 + 中等分配 (10-100MB)      4%         ⭐⭐  Async好
8线程 + 大分配 (>100MB)          14.5%      ⭐⭐  Pool好!
其他场景                          < 5%       ⭐

Arena                            不稳定      ❌ 避免
```

## 最终推荐 🏁

### 生产环境：Pool

**理由（更新）：**
1. ✅ 大分配场景明显更好（-14.5%）
2. ✅ 长期"越用越快"
3. ✅ 稳定可靠
4. ⚠️ 仅在8线程+中等分配时略差（+4%）

**权衡：** 
- 牺牲4%（中等分配）
- 换取14.5%（大分配）+ 整体稳定性
- **值得！**

### 开发/研究：Async

**理由：**
1. ✅ 零配置
2. ✅ 中等分配稍好
3. ⚠️ 大分配会慢8.5%

**适用：**
- 主要是中小分配
- 不在意8.5%的大分配退化
- 优先考虑开发便利性

### 避免：Arena

- ❌ 大分配直接OOM
- ❌ 16线程退化35%
- ❌ 不可靠

## 总结 📝

**你的直觉是对的！**
- ✅ 大分配确实暴露了更多差异（14.5%！）
- ✅ 但方向相反：Pool 在大分配时更好

**关键发现：**
1. **分配大小决定谁更好**
   - 中等（10-100MB）：Async 好 4%
   - 大（>100MB）：Pool 好 14.5%

2. **Pool 的"越用越快"**
   - 内部优化/合并机制
   - 长期表现excellent

3. **Async 只在特定场景有优势**
   - 8线程 + 中等分配
   - 其他场景无优势或更差

**最终答案：**
> **碎片化影响取决于分配大小。**
> 
> 大分配（>100MB）：Pool 因为更少的块搜索而更快
> 中等分配（10-100MB）：Async 因为stream-ordered而略快
> 
> **推荐生产用 Pool，因为：**
> - 大分配优势（14.5%）> 中等分配劣势（4%）
> - 整体更稳定可靠

---

## 测试复现

```bash
cd async_scenarios/build
./extreme_fragmentation_test
```

注意：需要 ≥16GB GPU 内存

